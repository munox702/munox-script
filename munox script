-- == ADMIN TOOLKIT UNIFICADO (ServerScriptService) ==
-- Cole este Script em ServerScriptService. Ele cria RemoteEvents, template, GUI e
-- handlers server-side. Substitua os AdminIds e personalize conforme necessário.

local Players = game:GetService("Players")
local Replicated = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local ServerStorage = game:GetService("ServerStorage")
local HttpService = game:GetService("HttpService") -- para gerar nomes únicos (não tem web calls)

-- ========== CONFIG ==========
local Admins = {
    -- Substitua por UserIds reais
    [12345678] = true,
    -- [87654321] = true,
}
local REQUIRE_CONSENT = false -- true exige que o dono aceite antes da transferência
local BASE_TELEPORT_CFRAME = CFrame.new(0, 10, 0) -- ajuste onde o admin teleporta
-- ============================

-- util: cria pasta RemoteEvents
local function ensureRemoteFolder()
    local folder = Replicated:FindFirstChild("RemoteEvents")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "RemoteEvents"
        folder.Parent = Replicated
    end
    return folder
end

local RE = ensureRemoteFolder()

local function ensureRemote(name)
    local ev = RE:FindFirstChild(name)
    if not ev then
        ev = Instance.new("RemoteEvent")
        ev.Name = name
        ev.Parent = RE
    end
    return ev
end

local RequestTransfer = ensureRemote("RequestTransfer")
local TeleportToBase = ensureRemote("TeleportToBase")
local SpawnBrainrot = ensureRemote("SpawnBrainrot")
local ToggleFly = ensureRemote("ToggleFly")
local ToggleInvisibility = ensureRemote("ToggleInvisibility")
local ToggleNoclip = ensureRemote("ToggleNoclip")
local ToggleInfiniteJump = ensureRemote("ToggleInfiniteJump")
local ConsentToggle = ensureRemote("SetConsent") -- para jogador dar consentimento (opcional)
local NotifyClient = ensureRemote("NotifyClient") -- para enviar mensagens rápidas ao cliente

-- cria BrainrotTemplate em ReplicatedStorage se não existir (Tool simples)
local function ensureBrainrotTemplate()
    local t = Replicated:FindFirstChild("BrainrotTemplate")
    if t then return t end

    -- criar um Tool simples com Handle
    local tool = Instance.new("Tool")
    tool.Name = "Brainrot"
    tool.CanBeDropped = true
    tool.Parent = Replicated

    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(1,1,1)
    handle.Anchored = false
    handle.CanCollide = true
    handle.Parent = tool

    -- simples visual
    local mesh = Instance.new("SpecialMesh", handle)
    mesh.MeshType = Enum.MeshType.Sphere
    mesh.Scale = Vector3.new(1.4,1.4,1.4)

    tool.TextureId = "" -- ajuste se tiver textura
    tool.Parent = Replicated
    tool.Name = "BrainrotTemplate"
    return Replicated:FindFirstChild("BrainrotTemplate")
end

local BrainrotTemplate = ensureBrainrotTemplate()

-- cria GUI em StarterGui (ScreenGui + Frame + botões + TextBox)
local function ensureAdminGui()
    if StarterGui:FindFirstChild("AdminMenu") then return end

    local screen = Instance.new("ScreenGui")
    screen.Name = "AdminMenu"
    screen.ResetOnSpawn = true
    screen.Parent = StarterGui

    local frame = Instance.new("Frame")
    frame.Name = "AdminFrame"
    frame.Size = UDim2.new(0, 220, 0, 360)
    frame.Position = UDim2.new(1, -230, 0.5, -180) -- painel lateral direita
    frame.AnchorPoint = Vector2.new(1, 0.5)
    frame.BackgroundTransparency = 0.15
    frame.BorderSizePixel = 0
    frame.Parent = screen

    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 28)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.SourceSansBold
    title.Text = "Admin Menu"
    title.TextSize = 18
    title.Parent = frame

    local function makeBtn(name, y, txt)
        local b = Instance.new("TextButton")
        b.Name = name
        b.Size = UDim2.new(1, -16, 0, 34)
        b.Position = UDim2.new(0, 8, 0, y)
        b.Font = Enum.Font.SourceSans
        b.TextSize = 16
        b.Text = txt
        b.Parent = frame
        return b
    end

    makeBtn("TeleportBtn", 40, "Teleport: Base")
    makeBtn("SpawnBtn", 84, "Spawn Brainrot")
    makeBtn("TransferBtn", 128, "Transferir Brainrot (UserId)")
    -- TextBox para UserId
    local tb = Instance.new("TextBox")
    tb.Name = "TargetUserIdBox"
    tb.Size = UDim2.new(1, -16, 0, 28)
    tb.Position = UDim2.new(0, 8, 0, 164)
    tb.PlaceholderText = "Digite UserId do alvo"
    tb.ClearTextOnFocus = false
    tb.Parent = frame

    makeBtn("FlyBtn", 200, "Toggle Fly")
    makeBtn("InvisBtn", 244, "Toggle Invis")
    makeBtn("NoclipBtn", 288, "Toggle Noclip")
    makeBtn("InfJumpBtn", 332, "Toggle InfJump")

    -- Nota pequena
    local note = Instance.new("TextLabel")
    note.Size = UDim2.new(1, -16, 0, 60)
    note.Position = UDim2.new(0, 8, 0, 372)
    note.TextWrapped = true
    note.Text = "Use apenas em seu jogo. Transferência ocorre só se Admin ou se alvo consentir."
    note.Font = Enum.Font.SourceSans
    note.TextSize = 12
    note.BackgroundTransparency = 1
    note.Parent = frame

    -- LocalScript (conteúdo abaixo será definido como Source)
    local localScript = Instance.new("LocalScript")
    localScript.Name = "AdminClient"
    localScript.Parent = frame

    local clientSource = [[
-- LocalScript: AdminClient (rodará no cliente)
local Players = game:GetService("Players")
local Replicated = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local player = Players.LocalPlayer

local RE = Replicated:WaitForChild("RemoteEvents")
local RequestTransfer = RE:WaitForChild("RequestTransfer")
local TeleportToBase = RE:WaitForChild("TeleportToBase")
local SpawnBrainrot = RE:WaitForChild("SpawnBrainrot")
local ToggleFly = RE:WaitForChild("ToggleFly")
local ToggleInvisibility = RE:WaitForChild("ToggleInvisibility")
local ToggleNoclip = RE:WaitForChild("ToggleNoclip")
local ToggleInfiniteJump = RE:WaitForChild("ToggleInfiniteJump")
local SetConsent = RE:WaitForChild("SetConsent")
local NotifyClient = RE:WaitForChild("NotifyClient")

local frame = script.Parent
local teleportBtn = frame:WaitForChild("TeleportBtn")
local spawnBtn = frame:WaitForChild("SpawnBtn")
local transferBtn = frame:WaitForChild("TransferBtn")
local flyBtn = frame:WaitForChild("FlyBtn")
local invisBtn = frame:WaitForChild("InvisBtn")
local noclipBtn = frame:WaitForChild("NoclipBtn")
local infJumpBtn = frame:WaitForChild("InfJumpBtn")
local targetBox = frame:WaitForChild("TargetUserIdBox")

local function notify(text)
    NotifyClient:FireServer(text) -- passa pro servidor para log/mostrar (servidor pode reenviar)
end

-- Teleport: pede o servidor para teletransportar (servidor valida admin)
teleportBtn.MouseButton1Click:Connect(function()
    TeleportToBase:FireServer() -- servidor usa BASE_TELEPORT_CFRAME
end)

-- Spawn Brainrot perto do jogador
spawnBtn.MouseButton1Click:Connect(function()
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    local pos = root and (root.Position + Vector3.new(0,0,-5)) or Vector3.new(0,5,0)
    SpawnBrainrot:FireServer(pos)
end)

-- Transferir Brainrot (envia UserId)
transferBtn.MouseButton1Click:Connect(function()
    local id = tonumber(targetBox.Text)
    if not id then
        notify("UserId inválido. Digite apenas números.")
        return
    end
    RequestTransfer:FireServer(id)
end)

-- Fly (toggle)
do
    local flying = false
    local bv
    flyBtn.MouseButton1Click:Connect(function()
        flying = not flying
        ToggleFly:FireServer(flying)
        local char = player.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        if flying then
            bv = Instance.new("BodyVelocity")
            bv.Name = "AdminFly_BV"
            bv.MaxForce = Vector3.new(1e5,1e5,1e5)
            bv.Parent = root
            spawn(function()
                while flying and bv.Parent do
                    local moveVec = Vector3.new(0,0,0)
                    if UIS:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + workspace.CurrentCamera.CFrame.LookVector end
                    if UIS:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec - workspace.CurrentCamera.CFrame.LookVector end
                    if UIS:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec - workspace.CurrentCamera.CFrame.RightVector end
                    if UIS:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + workspace.CurrentCamera.CFrame.RightVector end
                    if UIS:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0,1,0) end
                    if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then moveVec = moveVec - Vector3.new(0,1,0) end
                    bv.Velocity = Vector3.new(moveVec.X, moveVec.Y, moveVec.Z) * 50
                    task.wait(0.03)
                end
                if bv and bv.Parent then bv:Destroy() end
            end)
        else
            if bv and bv.Parent then bv:Destroy() end
        end
    end)
end

-- Invisibility
do
    local invisible = false
    invisBtn.MouseButton1Click:Connect(function()
        invisible = not invisible
        ToggleInvisibility:FireServer(invisible)
        local char = player.Character
        if not char then return end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = invisible and 1 or 0
            elseif part:IsA("Decal") or part:IsA("Texture") then
                part.Transparency = invisible and 1 or 0
            elseif part:IsA("Accessory") and part:FindFirstChild("Handle") then
                part.Handle.Transparency = invisible and 1 or 0
            end
        end
    end)
end

-- Noclip
do
    local noclip = false
    noclipBtn.MouseButton1Click:Connect(function()
        noclip = not noclip
        ToggleNoclip:FireServer(noclip)
        local char = player.Character
        if not char then return end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = not noclip
            end
        end
    end)
end

-- Infinite jump
do
    local infjump = false
    infJumpBtn.MouseButton1Click:Connect(function()
        infjump = not infjump
        ToggleInfiniteJump:FireServer(infjump)
    end)
    local function onChar(c)
        local humanoid = c:WaitForChild("Humanoid")
        humanoid.Jumping:Connect(function(active)
            if infjump and active then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    end
    if player.Character then onChar(player.Character) end
    player.CharacterAdded:Connect(onChar)
end

-- Recebe notificações do servidor (caso queira mostrar UI)
NotifyClient.OnClientEvent:Connect(function(msg)
    -- implementa mensagem visual simples (por enquanto print)
    print("[SERVER NOTICE] "..tostring(msg))
end)
]]

    localScript.Source = clientSource
end

ensureAdminGui()

-- ========== SERVER LOGIC (handlers) ==========
local consentFlags = {} -- consentFlags[userId] = true/false

local function isAdmin(player)
    if not player then return false end
    return Admins[player.UserId] == true
end

local function findBrainrotOf(player)
    if not player then return nil end
    local backpack = player:FindFirstChildOfClass("Backpack")
    if backpack then
        local item = backpack:FindFirstChild("Brainrot")
        if item then return item, "Backpack" end
    end
    if player.Character then
        local char = player.Character
        local tool = char:FindFirstChild("Brainrot")
        if tool then return tool, "Character" end
    end
    return nil
end

-- RequestTransfer handler
RequestTransfer.OnServerEvent:Connect(function(invoker, targetUserId)
    if typeof(targetUserId) ~= "number" then
        RequestTransfer:FireClient(invoker, false, "UserId inválido")
        return
    end
    if not isAdmin(invoker) then
        RequestTransfer:FireClient(invoker, false, "Apenas Admins podem solicitar transferências")
        return
    end
    local target = Players:GetPlayerByUserId(targetUserId)
    if not target then
        RequestTransfer:FireClient(invoker, false, "Jogador não encontrado")
        return
    end
    if REQUIRE_CONSENT and not consentFlags[targetUserId] then
        RequestTransfer:FireClient(invoker, false, "Consentimento necessário do dono")
        return
    end
    local brainrot = findBrainrotOf(target)
    if not brainrot then
        RequestTransfer:FireClient(invoker, false, "Brainrot não encontrado no alvo")
        return
    end
    -- Move com segurança para o Backpack do invoker
    local invBack = invoker:FindFirstChildOfClass("Backpack")
    if not invBack then
        RequestTransfer:FireClient(invoker, false, "Backpack do admin não encontrado")
        return
    end
    brainrot.Parent = invBack
    RequestTransfer:FireClient(invoker, true, "Transferência concluída")
    print(string.format("[AdminTool] %s transferiu Brainrot de %s", invoker.Name, target.Name))
end)

-- Consent handler (jogador define consentimento)
ConsentToggle.OnServerEvent:Connect(function(player, allow)
    if typeof(allow) ~= "boolean" then return end
    consentFlags[player.UserId] = allow
    NotifyClient:FireClient(player, "Consentimento definido: " .. tostring(allow))
end)

-- Teleport handler (teleporta admin para baseCFrame definido no servidor)
TeleportToBase.OnServerEvent:Connect(function(player)
    if not isAdmin(player) then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    hrp.CFrame = BASE_TELEPORT_CFRAME
end)

-- Spawn Brainrot (admin-only)
SpawnBrainrot.OnServerEvent:Connect(function(player, spawnPosition)
    if not isAdmin(player) then return end
    local template = Replicated:FindFirstChild("BrainrotTemplate")
    if not template then
        warn("BrainrotTemplate não encontrado.")
        return
    end
    local clone = template:Clone()
    clone.Name = "Brainrot"
    clone.Parent = workspace
    -- posiciona: aceita Vector3 ou nil
    local pos = typeof(spawnPosition) == "Vector3" and spawnPosition or (player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position + Vector3.new(0,5,0) or Vector3.new(0,5,0))
    if clone:IsA("Tool") then
        local handle = clone:FindFirstChild("Handle")
        if handle then
            handle.CFrame = CFrame.new(pos)
            clone.Parent = workspace
        end
    elseif clone:IsA("Model") and clone.PrimaryPart then
        clone:SetPrimaryPartCFrame(CFrame.new(pos))
    else
        -- fallback: cria um Part representando o item
        local p = Instance.new("Part")
        p.Name = "BrainrotPart"
        p.Size = Vector3.new(1,1,1)
        p.Position = pos
        p.Parent = workspace
    end
end)

-- Toggle events (server registra e apenas valida perms; cliente aplica)
ToggleFly.OnServerEvent:Connect(function(player, enable)
    if not isAdmin(player) then return end
    -- opcional: log
    print(("[AdminTool] %s toggled Fly -> %s"):format(player.Name, tostring(enable)))
end)
ToggleInvisibility.OnServerEvent:Connect(function(player, enable)
    if not isAdmin(player) then return end
    print(("[AdminTool] %s toggled Invis -> %s"):format(player.Name, tostring(enable)))
end)
ToggleNoclip.OnServerEvent:Connect(function(player, enable)
    if not isAdmin(player) then return end
    print(("[AdminTool] %s toggled Noclip -> %s"):format(player.Name, tostring(enable)))
end)
ToggleInfiniteJump.OnServerEvent:Connect(function(player, enable)
    if not isAdmin(player) then return end
    print(("[AdminTool] %s toggled InfJump -> %s"):format(player.Name, tostring(enable)))
end)

-- NotifyClient (quando cliente pede notificação, servidor pode logar ou redirecionar)
NotifyClient.OnServerEvent:Connect(function(player, msg)
    if typeof(msg) ~= "string" then return end
    -- reenviar para o próprio cliente (ou para admins / logs)
    NotifyClient:FireClient(player, msg)
    print(("[Notify] %s -> %s"):format(player.Name, msg))
end)

print("Admin Toolkit unificado carregado. Lembre-se de ajustar Admins[] com seus UserIds.")
